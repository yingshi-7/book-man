# 一、环境准备

### 1.1 创建vue工程（book-man）

```js
npm init vue@latest

cd book-man
npm install
```

### 1.2 安装插件

1. 安装element-plus

  ```js
  1.1 执行命令： npm install element-plus --save
  1.2 在main.js中做如下配置：
    import ElementPlus from 'element-plus'
    import 'element-plus/dist/index.css'
    app.use(ElementPlus) 
  ``` 

2. 安装axios

  ```js
  npm install axios --save

3. 安装sass依赖

  ```js
  npm install sass -D
  ```

### 1.3 目录调整
1. 删除components目录下的内容

2. 删除App.vue中的内容，只保留script和template标签

3. 新建如下目录：

  api：存放接口调用的js文件

  utils：存放工具类js文件
        
        新建request.js文件
  
  views：存放页面的.vue文件

4. 删除assets目录中的内容，将资料中的静态资源文件全部拷贝到该目录下

# 二、注册

### 2.1 页面搭建

Login.vue

```html
<!-- 登陆页面 -->
<script setup>
import { User, Lock } from '@element-plus/icons-vue'
import { ref } from 'vue'
//控制注册和登录表单的显示，默认显示登录
const isRegister = ref(false)
</script>

<template>
  <el-row class="login-page">
    <el-col :span="12" class="bg"></el-col>
    <el-col :span="6" :offset="3" class="form">
      <!-- 注册表单 -->
      <el-form ref="form" size="large" autocomplete="off" v-if="isRegister">
        <el-form-item>
          <h1>注册</h1>
        </el-form-item>
        <el-form-item>
          <el-input :prefix-icon="User" placeholder="请输入用户名"></el-input>
        </el-form-item>
        <el-form-item>
          <el-input :prefix-icon="Lock" type="password" placeholder="请输入密码"></el-input>
        </el-form-item>
        <el-form-item>
          <el-input :prefix-icon="Lock" type="password" placeholder="请再次输入密码"></el-input>
        </el-form-item>
        <!-- 注册按钮 -->
        <el-form-item>
          <el-button class="button" type="primary" auto-insert-space>
            注册
          </el-button>
        </el-form-item>
        <el-form-item class="flex">
          <el-link type="info" :underline="false" @click="isRegister = false">
            ← 返回
          </el-link>
        </el-form-item>
      </el-form>
      <!-- 登录表单 -->
      <el-form ref="form" size="large" autocomplete="off" v-else>
        <el-form-item>
          <h1>登录</h1>
        </el-form-item>
        <el-form-item>
          <el-input :prefix-icon="User" placeholder="请输入用户名"></el-input>
        </el-form-item>
        <el-form-item>
          <el-input name="password" :prefix-icon="Lock" type="password" placeholder="请输入密码"></el-input>
        </el-form-item>
        <el-form-item class="flex">
          <div class="flex">
            <el-checkbox>记住我</el-checkbox>
            <el-link type="primary" :underline="false">忘记密码?</el-link>
          </div>
        </el-form-item>
        <!-- 登录按钮 -->
        <el-form-item>
          <el-button class="button" type="primary" auto-insert-space>登录</el-button>
        </el-form-item>
        <el-form-item class="flex">
          <el-link type="info" :underline="false" @click="isRegister = true">
            注册 →
          </el-link>
        </el-form-item>
      </el-form>
    </el-col>
  </el-row>
</template>

<style lang="scss" scoped>
/* 样式 */
.login-page {
  height: 100vh;
  background-color: #fff;

  .bg {
    background: url('@/assets/logo2.png') no-repeat 60% center / 240px auto,
      url('@/assets/login_bg.jpg') no-repeat center / cover;
    border-radius: 0 20px 20px 0;
  }

  .form {
    display: flex;
    flex-direction: column;
    justify-content: center;
    user-select: none;
  
    .title {
      margin: 0 auto;
    }

    .button{
      width: 100%;
    }

    .flex {
      width: 100%;
      display: flex;
      justify-content: space-between;
    }
  }
}
</style>
```

### 2.2 页面数据绑定与事件绑定

#### 2.2.1 数据绑定

```js
//用于注册的数据模型
const registerData = ref({
    username: '',
    password: '',
    rePassword: ''
})
```

#### 2.2.2 表单校验

```js
//自定义确认密码的校验函数
const rePasswordValid = (rule, value, callback) => {
    if (value == null || value === '') {
        return callback(new Error('请再次确认密码'))
    }
    if (registerData.password !== value) {
        return callback(new Error('两次输入密码不一致'))
    }
}
//用于注册的表单校验模型
const registerRules = ref({
  username: [
    { required: true, message: '请输入用户名', trigger: 'blur' },
    { min: 3, max: 16, message: '长度为3~16位非空字符', trigger: 'blur' },
  ],
  password: [
    { required: true, message: '请输入密码', trigger: 'blur' },
    { min: 6, max: 16, message: '长度为6~16位非空字符', trigger: 'blur' },
  ],
  rePassword: [{ validator: rePasswordValid, trigger: 'blur' }]
})
```

#### 2.2.3 事件绑定

```js
//用于注册的事件函数
const register = () => {
    console.log('注册...');
}
```

### 2.3 接口调用

#### 2.3.1 在src/api/user.js中提供访问注册接口的函数

```js
//注册接口
export const registerService = (registerData) => {
    var params = new URLSearchParams()
    for (let key in registerData) {
        params.append(key, registerData[key])
    }
    return request.post('/user/register', params)
}
```

#### 2.3.2 在Login.vue中完成注册接口调用

```js
import { registerService} from '@/api/user.js'
//用于注册的事件函数
const register = async () => {
    //console.log('注册...');
    let result = await registerService(registerData.value);
    if (result.code == 0) {
        alert('注册成功!')
    } else {
        alert('注册失败!')
    }
}
```

### 2.4 处理跨域问题

由于发起ajax请求的域为http://localhost:5173, 而后台服务器的域为 http://localhost:8091, 所以浏览器会限制该请求的发送, 这种问题称为跨域问题, 跨域问题可以在服务器端解决,也可以在浏览器端解决, 咱们这一块通过配置代理的方式解决

**request.js中配置统一前缀 /api**

```js
//定制请求的实例

//导入axios  npm install axios
import axios from 'axios';
//定义一个变量,记录公共的前缀  ,  baseURL
const baseURL = '/api';
const instance = axios.create({baseURL})


//添加响应拦截器
instance.interceptors.response.use(
    result=>{
        return result.data;
    },
    err=>{
        alert('服务异常');
        return Promise.reject(err);//异步的状态转化成失败的状态
    }
)

export default instance;
```


**vie.config.js中配置代理**

```js
import { fileURLToPath, URL } from 'node:url'

import { defineConfig } from 'vite'
import vue from '@vitejs/plugin-vue'

// https://vitejs.dev/config/
export default defineConfig({
  plugins: [
    vue(),
  ],
  resolve: {
    alias: {
      '@': fileURLToPath(new URL('./src', import.meta.url))
    }
  },
  //配置代理
  server: {
    proxy: {
      '/api': {
        target: 'http://localhost:8091', // 后端服务器地址
        changeOrigin: true, // 是否改变请求域名
        rewrite: (path) => path.replace(/^\/api/, '')//将原有请求路径中的api替换为''
      }
    }
  }
})

```



# 三、登录

### 3.1页面数据绑定与事件绑定

#### 3.1.1 绑定数据

```js
//复用注册表单的数据模型
const registerData = ref({
    username: '',
    password: '',
    rePassword: ''
})
```

#### 3.1.2 每次点击注册或者登录，共用数据模型中的数据

```js
//清空数据模型的数据
const clearRegisterData = () => {
    registerData.value = {
        username: '',
        password: '',
        rePassword: ''
    }
}
```

#### 3.1.3 事件绑定

```js
const login =  () => {
    
}
```

### 3.2 接口调用

#### 3.2.1 在src/api/user.js中提供访问注册接口的函数

```js
//登录
export const loginService = (loginData)=>{
    var params = new URLSearchParams()
    for(let key in loginData){
        params.append(key,loginData[key])
    }
    return request.post('/user/login',params)
}
```

#### 3.2.2 在Login.vue中完成登录接口调用

```js
import { registerService, loginService } from '@/api/user.js'

//用于登录的事件函数
const login = async () => {
    let result = await loginService(registerData.value)
    if(result.code==0){
        alert('登录成功!')
    }else{
        alert('登录失败!')
    }
}
```


# 四、优化axios响应截器

在接口调用的API中，我们都需要对业务响应的状态进行判断，从而给用户对应的提示，这个工作不难，但是每个接口的调用，都这样写代码，显然是比较繁琐的，我们可以在axios的相应拦截器中，如果服务器响应成功了，统一判断后台返回的业务状态码code，如果成功了，正常返回数据，如果失败了，则给出用户对应的提示即可

**请求工具request.js**

```js
//添加响应拦截器
instance.interceptors.response.use(
    result => {
        //如果业务状态码为0，代表本次操作成功
        if (result.data.code == 0) {
            return result.data;
        }
        //代码走到这里，代表业务状态码不是0，本次操作失败
        alert(result.data.message || '服务异常');
        return Promise.reject(result.data);//异步的状态转化成失败的状态
    },
    err => {
        alert('服务异常');
        return Promise.reject(err);//异步的状态转化成失败的状态
    }
)
```

**接口调用user.js**

```js
//用于注册的事件函数
const register = async () => {
    //console.log('注册...');
    await registerService(registerData.value);
    alert('注册成功!')

}

//用于登录的事件函数
const login = async () => {
    await loginService(registerData.value)
    alert('登录成功!')
    
}
```



**Element-Plus提示框的使用**

```js
import { ElMessage } from 'element-plus'

ElMessage.error('服务异常');
ElMessage.success('登录成功!')
```



# 五、主页面布局



```html
<script setup>
import {
    Management,
    Promotion,
    UserFilled,
    User,
    Crop,
    EditPen,
    SwitchButton,
    CaretBottom
} from '@element-plus/icons-vue'
import avatar from '@/assets/default.png'
</script>

<template>
    <el-container class="layout-container">
        <!-- 左侧菜单 -->
        <el-aside width="200px">
            <div class="el-aside__logo"></div>
            <el-menu default-active="1" active-text-color="#ffd04b" background-color="#232323"  text-color="#fff"
                router>
              <el-menu-item index="1">
                <el-icon>
                  <icon-menu />
                </el-icon>
                <template #title>图书管理</template>
              </el-menu-item>
              <el-menu-item index="2">
                <el-icon>
                  <document />
                </el-icon>
                <template #title>借阅管理</template>
              </el-menu-item>
              <el-menu-item index="3">
                <el-icon>
                  <setting />
                </el-icon>
                <template #title>用户管理</template>
              </el-menu-item>
              <el-sub-menu index="4">
                <template #title>
                  <el-icon>
                    <DataLine />
                  </el-icon>
                  <span>报表统计</span>
                </template>
                <el-menu-item index="4-1">图书统计</el-menu-item>
                <el-menu-item index="4-2">借阅统计</el-menu-item>
                <el-menu-item index="4-3">用户统计</el-menu-item>
              </el-sub-menu>
              <el-sub-menu index="5">
                <template #title>
                  <el-icon>
                    <UserFilled />
                  </el-icon>
                  <span>个人中心</span>
                </template>
                <el-menu-item index="5-1">基本资料</el-menu-item>
                <el-menu-item index="5-2">更换头像</el-menu-item>
                <el-menu-item index="5-3">重置密码</el-menu-item>
              </el-sub-menu>
            </el-menu>
        </el-aside>
        <!-- 右侧主区域 -->
        <el-container>
            <!-- 头部区域 -->
            <el-header>
                <div>当前用户: <strong>图书管理系统</strong></div>
                <el-dropdown placement="bottom-end">
                    <span class="el-dropdown_box">
                        <el-avatar :src="avatar" />
                        <el-icon>
                            <CaretBottom />
                        </el-icon>
                    </span>
                    <template #dropdown>
                        <el-dropdown-menu>
                            <el-dropdown-item :icon="User">基本资料</el-dropdown-item>
                            <el-dropdown-item :icon="Crop">更换头像</el-dropdown-item>
                            <el-dropdown-item :icon="EditPen">重置密码</el-dropdown-item>
                            <el-dropdown-item :icon="SwitchButton">退出登录</el-dropdown-item>
                        </el-dropdown-menu>
                    </template>
                </el-dropdown>
            </el-header>
            <!-- 中间区域 -->
            <el-main>
                <div style="width: 1290px; height: 570px;border: 1px solid red;">
                    内容展示区
                </div>
            </el-main>
            <!-- 底部区域 -->
            <el-footer>大事件 ©2023 Created by 黑马程序员</el-footer>
        </el-container>
    </el-container>
</template>

<style lang="scss" scoped>
.layout-container {
  height: 100vh;

  .el-aside {
    background-color: #8b8b8b;

    &_logo {
      height: 120px;
      background: url('@/assets/logo3.png') no-repeat center / 150px auto;
    }

    .el-menu {
      border-radius: none;
    } 
  }

  .el-header {
    background-color: #fff;
    display: flex;
    align-items: center;
    justify-content: space-between;

    .el-dropdown_box {
      display: flex;
      align-items: center;
    }

    .el-icon {
      color: #999;
      margin-left: 10px;
    }

    &:active,
    &:focus {
      outline: none;
    }
  }

  .el-footer {
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 14px;
    color: #666
  }
}
</style>
```



# 六、路由

在App.vue中，不能同时展示Login.vue和Layout.vue，实际的需求是用户第一次访问程序，先展示登录页面，当用户登录成功后，再展示主页面，如果要达成这个需求，需要用到vue提供的路由相关的知识

路由，从起点到终点时，决定从起点到终点的路径的进程，在前端工程中，路由指的是根据不同的访问路径，展示不同组件的内容。Vue Router是Vue.js的官方路由，它与Vue.js深度集成，让Vue.js构建单页面应用变得更加轻而易举



### 6.1安装路由

```js
npm install vue-router@4
```



### 6.2创建路由器，并导出

在src/router目录下，定义一个js文件，起名为index.js。这样名字的js文件在导入时，可以不写文件名，只要定位到文件所在的文件夹即可，使用起来很方便

```js
//导入vue-router
import { createRouter, createWebHistory } from 'vue-router'
//导入组件
import LoginVue from '@/views/Login.vue'
import LayoutVue from '@/views/Layout.vue'

//定义路由关系
const routes = [
    { path: '/login', component: LoginVue },
    { path: '/', component: LayoutVue }
]

//创建路由器
const router = createRouter({
    history: createWebHistory(),
    routes: routes
});

export default router
```



### 6.3在vue应用实例中使用router

在main.js中导入创建应用实力的js文件，并调用实例的use方法使用路由器

```js
import router from '@/router'

app.use(router)
```



### 6.4定义展示路由组件的地方

在App.vue文件的template标签中，定义router-view标签

```html
<template>
   <router-view></router-view>
</template>
```

将来不管根据路由匹配到的组件内容，会在router-view标签内进行展示



### 6.5 测试

在浏览器地址栏分别访问：http://localhost:5173/    和   http://localhost:5173/login



### 6.6 路由API

在登录成功后，需要通过代码的方式将页面切换到首页，此时就需要调用路由器相关的API

**获取路由器**

```js
import { useRouter } from 'vue-router'
const router = useRouter();
```

**调用API**

```js
router.push('/')
```



# 七、子路由

在咱们的主页面中，当用户点击左侧的菜单时，右侧主区域的内容需要发生变化，将来每切换一个菜单，右侧需要加载对应组件的内容进行展示，像这样的场景咱们也需要使用路由来完成

由于这些组件都需要在Layout.vue中展示， 而Layout.vue本身已经参与了路由，因此我们需要在Layout.vue中通过子路由的方式来完成组件的切换

### 7.1提供菜单对应的组件

可以复制资料中的文件，也可以自己创建：

- BookMan.vue
- BorrowMan.vue
- UserMan.vue
- UserAvatar.vue
- UserInfo.vue
- UserResetPassword.vue
- ReportBook.vue
- ReportBorrow.vue
- ReportUser.vue



### 7.2配置子路由

在src/router/index.js中配置子路由

```js
// 定义路由关系
const routes = [
  { path: '/login', component: LoginVue },
  {
    path: '/',
    component: LayoutVue,
    // 重定向到登录页面
    redirect: '/login',
    // 子路由
    children: [
      { path: '/man/books', component: BookManVue },
      { path: '/man/borrows', component: BorrowManVue },
      { path: '/man/users', component: UserManVue },
      { path: '/user/avatar', component: UserAvatarVue },
      { path: '/user/info', component: UserInfoVue },
      { path: '/user/password', component: UserResetPasswordVue },
      { path: '/report/books', component: ReportBookVue },
      { path: '/report/borrows', component: ReportBorrowVue },
      { path: '/report/users', component: ReportUserVue },
    ]
  }
]
```



### 7.3 在Layout.vue组件的右侧中间区域，添加router-view标签

```html
<!-- 中间区域 -->
<el-main>
    <div style="width: 1290px; height: 570px;border: 1px solid red;">
        <router-view></router-view>
    </div>
</el-main>
```



### 7.4 菜单项设置点击后跳转的路由路径

el-menu-item 标签的index属性可以设置点击后的路由路径

```html
<el-menu-item index="/article/category">
    <el-icon>
        <Management />
    </el-icon>
    <span>文章分类</span>
</el-menu-item>
```



# 八、图书管理页面列表

### 8.1 图书管理页面数据模型组件

```html
<!-- 图书管理页面 -->
<script setup>
import { Edit, Delete } from '@element-plus/icons-vue'
import { ref } from 'vue'
const bookData = ref([
  { name: '《三国演义》', author: '罗贯中', publishingHouse: '北京出版社', category: '文学', createTime: '1997-05-01', updateTime: '1997-05-01', address: '北京出版社' },
  { name: '《水浒传》', author: '施耐奄', publishingHouse: '北京出版社', category: '文学', createTime: '1997-05-01', updateTime: '1997-05-01', address: '北京出版社' },
  { name: '《西游记》', author: '吴承恩', publishingHouse: '北京出版社', category: '文学', createTime: '1997-05-01', updateTime: '1997-05-01', address: '北京出版社' },
  { name: '《红楼梦》', author: '曹雪芹', publishingHouse: '北京出版社', category: '文学', createTime: '1997-05-01', updateTime: '1997-05-01', address: '北京出版社' },
])

const searchData = ref({
  name: '',
  author: '',
  publishingHouse: '',
  category: ''
})
</script>

<template>
  <el-card class="page-container">
    <template #header>
      <div class="header">
        <div class="select">
          <div>
            <span>书名：</span>
            <el-input class="input" v-model="searchData.name" placeholder="请输入图书名称" />
            <span>作者：</span>
            <el-input class="input" v-model="searchData.author" placeholder="请输入作者名称" />
            <span>出版社：</span>
            <el-input class="input" v-model="searchData.publishingHouse" placeholder="请输入出版社名称" />
            <span>类别：</span>
            <el-input class="input" v-model="searchData.category" placeholder="请输入类别名称" />
          </div>
          <el-button class="search" type="primary">搜索</el-button>
        </div>
        <div class="extra">
          <el-button type="primary">新增图书</el-button>
        </div>
      </div>
    </template>
    <el-table :data="bookData" style="width: 100%">
      <el-table-column label="序号" width="100" type="index" />
      <el-table-column prop="name" label="图书" />
      <el-table-column prop="author" label="作者" />
      <el-table-column prop="publishingHouse" label="出版社" />
      <el-table-column prop="category" label="分类" />
      <el-table-column prop="createTime" label="创建时间" />
      <el-table-column prop="updateTime" label="更新时间" />
      <el-table-column label="操作" width="100">
        <template #default="{ row }">
          <!-- row 代表当前行的数据,后续在按钮的点击事件中可以用 row 获取当前行的数据 -->
          <el-button :icon="Edit" circle plain type="primary"></el-button>
          <el-button :icon="Delete" circle plain type="danger"></el-button>
        </template>
      </el-table-column>
      <template #empty>
        <el-empty description="没有数据" />
      </template>
    </el-table>
  </el-card>
</template>

<style scoped lang="scss">
.page-container {
  min-height: 100%;
  box-sizing: border-box;

  .header {
    display: flex;
    align-items: center;
    justify-content: space-between;
  }

  .select {
    display: flex;

    .input {
      width: 200px;
    }

    .search {
      margin-left: 15px;
    }
  }
}
</style>
```

### 8.2 列表接口调用

src/api/man.js
```js
import request from '@/utils/request'

// 获取图书列表
export const getBookList = () => {
  return request.get('/library')
}
```

BookMan.vue

```js
// 获取所有图书信息列表
import { getBookList } from '@/api/man';
const getAllBookList = async () => {
  let res = await getBookList()
  console.log(res? res:'获取图书列表失败');
}
getAllBookList()
```

但是上述的代码并不能真正的获取到所有文章分类数据，服务器响应状态码为401，因为目前请求头中并没有携带token



# 九、Pinia状态管理库

Pinia是Vue的专属状态管理库，它允许你跨组件或页面共享状态

### 9.1安装

```js
npm install pinia
```

### 9.2使用Pinia

在main.js中，引入pinia，创建pinia实例，并调用vue应用实例的use方法使用pinia

```js
import { createPinia } from 'pinia'

const pinia = createPinia()
app.use(pinia)
```


### 9.3 定义Store

在src/stores目录下定义token.js

<<<<<<< HEAD
```js
import { defineStore } from "pinia";
import { ref } from 'vue'

/**
 * defineStore参数描述：
 *   第一个参数：给状态起名，具有唯一性
 *   第二个参数：函数，可以把定义该状态中拥有的内容都放在里面
 * 
 * defineStore返回值：
 *   返回的是一个函数，将来可以调用该函数，得到第二个参数中返回的内容
 */

export const useTokenStore = defineStore('token', () => {
  //1.定义描述token
  const token = ref('')

  //2.定义修改token的方法
  const setToken = (newToken) => {
    token.value = newToken
  }

  //3.定义清除token的方法
  const removeToken = () => {
    token.value = ''
  }

  //4.返回内容
  return { token, setToken, removeToken }
})
```

### 9.4 使用Store

在需要使用状态的地方，导入@/stores/*.js , 使用即可

在Login.vue中导入@/stores/token.js, 并且当用户登录成功后，将token保存pinia中

```js
//导入token状态
import { useTokenStore } from '@/stores/token.js'

//调用useTokenStore得到状态
const tokenStore = useTokenStore();

//用于登录的事件函数
const login = async () => {
  let res = await userLoginService(registerData.value)
  //添加token
  tokenStore.setToken(res.data)
  
  ElMessage.success('登录成功!')
  //跳转到首页  路由完成操作
  router.push('/man/books')
}
```


在article.js中导入@/stores/token.js, 从pinia中获取到存储的token，在发起查询文章分类列表的时候把token通过请求头的形式携带给服务器


```js
//导入@/stores/token.js
import { useTokenStore } from '../stores/token'


// 获取图书列表
export const getBookList = () => {
  const tokenStore = useTokenStore()
  //通过请求头Authorization携带token
  return request.get('/library', {headers:{'Authorization':tokenStore.token}})
}
```



# 十、axios请求拦截器

当进入主页后，将来要与后台交互，都需要携带token，如果每次请求都写这样的代码，将会比较繁琐，此时可以将携带token的代码通过请求拦截器统一处理

在 src/util/request.js中

```js
//导入token状态
import { useTokenStore } from '@/stores/token.js';
// 添加请求拦截器
instance.interceptors.response.use(
    config => {
        // 在发送请求之前
        let tokenStore = useTokenStore()
        // 判断是否有token
        if (tokenStore.token){
            config.headers.Authorization = tokenStore.token
        }
        return config
    },
    error => {
        //请求错误的回调,将异步的状态转化成失败的状态
        return Promise.reject(error)
    }
)
```



# 十一、Pinia持久化插件

默认情况下，由于pinia是内存存储，当你刷新页面的时候pinia中的数据会丢失，可以借助于persist插件解决这个问题，persist插件支持将pinia中的数据持久化到sessionStorage和localStorage中

### 11.1 安装persist插件

```js
npm install pinia-persistedstate-plugin
```



### 11.2 pinia中使用persist插件

在main.js中

```js
import { createPinia } from 'pinia'
//导入持久化插件
import {createPersistedState} from'pinia-persistedstate-plugin'
const pinia = createPinia()
const persist = createPersistedState()
//pinia使用持久化插件
pinia.use(persist)
app.use(pinia)
```



### 11.3 在创建定义状态时配置持久化

在 sre/stores/token.js中

```js
export const useTokenStore = defineStore('token', () => {
  //1.定义描述token
  const token = ref('')

  //2.定义修改token的方法
  const setToken = (newToken) => {
    token.value = newToken
  }

  //3.定义清除token的方法
  const removeToken = () => {
    token.value = ''
  }

  //4.返回内容
  return { token, setToken, removeToken }
},
  // 参数持久化
  {
    persist: true
  }
)
```



# 十二、未登录统一处理

在后续访问接口时，如果没有登录，则前端不携带token，后台服务器会返回响应状态码401，代表未登录，此时可以在axios的响应拦截器中，统一对未登录的情况做处理

**request.js**

```js
import router from '@/router'

//添加响应拦截器
instance.interceptors.response.use(
    result => {
        //判断业务状态码
        if (result.data.code === 0) {
            return result.data;
        }
        // 错误处理
        // alert(result.data.msg ? result.data.msg : '服务异常');
        ElMessage.error(result.data.message ? result.data.message : '服务异常')
        //异步的状态转化成失败的状态
        return Promise.reject(result.data);
    },
    err => {
        // 如果响应状态码是401，代表未登录，给出对应的提示，并跳转到登录页
        if (err.response.status === 401) {
            ElMessage.error('请先登录!')
            router.push('/login')
        } else {
            ElMessage.error('服务异常')
        }
        // alert('服务异常');
        return Promise.reject(err);//异步的状态转化成失败的状态
    }
)
```




# 十三、添加新增图书

### 13.1 添加新增图书弹窗页面

```html
<!-- 添加新增图书弹窗 -->
<el-dialog v-model="dialogVisible" title="添加弹窗" width="30%">
  <el-form :model="bookModel" :rules="rules" label-width="100px" style="padding-right: 30px;">
    <el-form-item label="图书名称" prop="bookName">
      <el-input v-model="bookModel.bookName" minlength="1" maxlength="10" />
    </el-form-item>
    <el-form-item label="图书作者" prop="author">
      <el-input v-model="bookModel.author" minlength="1" maxlength="10" />
    </el-form-item>
    <el-form-item label="出版社" prop="publishingHouse">
      <el-input v-model="bookModel.publishingHouse" minlength="1" maxlength="10" />
    </el-form-item>
    <el-form-item label="图书类别" prop="category">
      <el-input v-model="bookModel.category" minlength="1" maxlength="10" />
    </el-form-item>
  </el-form>
  <template #footer>
    <div class="dialog-footer">
      <el-button @click="dialogVisible = false">取消</el-button>
      <el-button type="primary" @click="dialogVisible = false">
        确认
      </el-button>
    </div>
  </template>
</el-dialog>
```

### 13.2 数据模型和校验规则

```js
// 添加新增图书弹窗控制器
const dialogVisible = ref(false)

// 添加新增图书数据模型(与图书搜索数据模型一致)
const bookModel = ref({
  bookName: '',
  author: '',
  publishingHouse: '',
  category: '',
  createUser: ''
})

//添加分类表单校验
const rules = {
  bookName: [
    { required: true, message: '请输入图书名称', trigger: 'blur' },
  ],
  author: [
    { required: true, message: '请输入图书作者', trigger: 'blur' },
  ],
  publishingHouse: [
    { required: true, message: '请输入图书出版社', trigger: 'blur' },
  ],
  category: [
    { required: true, message: '请输入图书类别', trigger: 'blur' },
  ]
}
```

### 13.3 添加新增图书按钮点击事件

```html
 <el-button type="primary" @click="dialogVisible = true">新增图书</el-button>
```

### 13.4 接口调用

**在man.js中提供添加新增图书的函数**

```js
// 新增图书信息
export const addBookService = (bookData) => {
  return request.post('/library',bookData)
}
```

**在页面中调用接口**

```js
// 新增图书
const addBook = async () => {
  let res = await addBookService(bookModel.value)
  ElMessage.success(res.message ? res.message : '新增图书成功')
  // 关闭弹窗
  dialogVisible.value = false
  // 刷新图书列表
  getAllBookList()
}
```

```html
<el-button type="primary" @click="addBook"> 确认 </el-button>
```



# 十四、修改图书信息

### 14.1 修改图书信息弹窗页面

修改图书信息弹窗和新增图书信息分类弹窗长的一样，所以可以服用添加图书的弹窗

**弹窗标题显示**
定义标题

```js
//弹窗标题
const title=ref('')
```

在弹窗上绑定标题

```html
 <el-dialog v-model="dialogVisible" :title="title" width="30%">
```

为新增图书按钮添加title属性

```html
<el-button type="primary" @click="title='新增图书';dialogVisible = true">新增图书</el-button>
```

为修改图书信息按钮添加title属性及绑定事件

```html
<el-button :icon="Edit" circle plain type="primary" @click="title='编辑图书';dialogVisible=true"></el-button>
```



### 14.2 数据回显

当点击修改分类按钮时，需要把当前这一条数据的详细信息显示到修改分类的弹窗上，这个叫回显

**通过插槽的方式得到被点击按钮所在行的数据**

```html
<template #default="{ row }">
  <!-- row 代表当前行的数据,后续在按钮的点击事件中可以用 row 获取当前行的数据 -->
  <el-button :icon="Edit" circle plain type="primary" @click="showDialog(row)"></el-button>
  <el-button :icon="Delete" circle plain type="danger"></el-button>
</template>
```

**回显函数**

```js
// 修改图书信息回显
const showDialog = (row) => {
  title.value = '编辑图书'
  dialogVisible.value = true
  //将row中的数据赋值给bookModel
  bookModel.value = { ...row }
}
```



### 14.3 接口调用

**article.js中提供修改分类的函数**

```js
// 修改图书信息
export const updateBookService = (bookData) => {
  return request.put('/library',bookData)
}
```

**修改确定按钮的绑定事件**

```html
<div class="dialog-footer">
  <el-button @click="dialogVisible = false">取消</el-button>
  <el-button type="primary" @click="title === '新增图书' ? addBook() : updateBook()"> 确认 </el-button>
</div>
```

**调用接口完成修改的函数**

```js
// 修改图书信息
const updateBook = async () => {
  let res = await updateBookService(bookModel.value)
  ElMessage.success(res.message ? res.message : '修改图书成功')
  // 关闭弹窗
  dialogVisible.value = false
  // 刷新图书列表
  getAllBookList()
}
```



由于现在修改和新增共用了一个数据模型，所以在点击新增图书后，有时候会显示数据，此时可以将bookModel中的数据清空

```js
// 清空模型数据
const clearBookModel = () => {
  bookModel.value = { ...'' }
}
```



修改新增图书按钮的点击事件

```html
<el-button type="primary" @click="title ='新增图书';dialogVisible=true;clearBookModel()">新增图书</el-button>
```




# 十五、删除图书信息

### 15.1 确认框

```js
//删除分类  给删除按钮绑定事件
const deleteCategory = (row) => {
  ElMessageBox.confirm(
    '你确认删除该分类信息吗？',
    '温馨提示',
    {
        confirmButtonText: '确认',
        cancelButtonText: '取消',
        type: 'warning',
    })
    .then(() => {
        //用户点击了确认
        ElMessage({
            type: 'success',
            message: '删除成功',
        })
    })
    .catch(() => {
        //用户点击了取消
        ElMessage({
            type: 'info',
            message: '取消删除',
        })
    })
}
```